#依据位移进行转移的jmp指令

- 指令格式为:
 - jmp short 标号(转到标号处执行指令)
 - 这种格式为jmp指令实现的是段内短转移
 - 本指令对IP的修改范围是-128~127,也就说向前转移最多128个字节，向后转移最多127个字节
 - short符号表示指令进行的是短转移
 - jmp指令中的“标号”，是代码段中的标号，指明了指令要转移的目的地址，转移指令结束后，CS:IP指向标号处的指令。

- 程序9.1:
``` asm
assume cs:codesg

codesg segment
    start: mov ax,0
           jmp short s
           add ax,1
    s:     inc ax
codesg ends
end start

;上面指令执行后ax的值加一，因为执行了jmp short s后指令越过了add ax,1，转移到了标号s处执行
;inc ax。也就是说，程序只进行了一次ax+1的操作

;汇编指令对应的机器指令:

;一般汇编指令对应的机器指令:
汇编指令              机器指令
mov ax, 0123h          B8 21 01
mov ax, ds: [0123h]    A1 23 01
push ds: [0123h]       FF 36 23 01
;可以看到，在一般汇编指令中，汇编指令中的立即数(idata)，不论它是表示一个数据还是
;内存单元的偏移地址，都会在对应的机器指令中出现，因为CPU执行的是机器指令，他必须要处理这些数据

;在Debug中将程序9.1翻译成为机器码，结果如下:

OBBD: 0000 B80000      MOV   AX,0000
OBBD: 0003 EBO3        JMP   0008
OBBD: 0005 050100      ADD   AX,0001
OBBD: 0008 40          INC   AX

;debug将jmp short s中的s表示为inc ax,指令的偏移地址为8
;jmp short s 表示为 jmp 0008,表示转移到了cs:0008处
;以上机器码出现的问题:
;jmp 0008(Debug 中的表示) 或 jmp short s 所对应的机器码为EB 03,这个机器码中不包含转移的目的地址,这意味着CPU在执行机器码EB 03时，并不知道转移的目的地址。
;那么，在没有转移目的地址的情况下CPU如何知道转移到哪里呢？
```
- 把程序9.1的代码改写成如下代码:
  - 程序9.2
  ``` asm
  assume cs:codesg
  codesg segment
    start: mov ax,0
           mov bx,0
           jmp short s
           add ax,1
    s:     inc ax
  codesg ends
  end start

  ;使用debug,将程序9.2翻译为机器码
  0BBD:0000 B80000  MOV   AX,0000
  OBBD:0003 BBO000  MOV   BX,0000
  OBBD:0006 EBO3    JMP   000B
  OBBD:0008 050100  ADD   AX,0001
  0BBD:000B 40      INC   AX
  ;比较9.1和9.2用Debug查看结果:
  ;1.两个程序都使用jmp指令指向了inc ax指令
  ;2.程序9.1的inc ax指令偏移地址为8,程序9.2的偏移地址为000BH
  ;3.两个程序中jmp指令所对应的机器码都是EB 03,这说明**CPU在执行jmp指令时不需要转移的目的地址**
  ;4.两个程序中jmp包含的转移目的地址不一样，一个是cs:0008,另一个是cs:000B,如果机器指令包含转移地址的话，那么它们对应的机器码应该是不同的
  ;5.CPU不需要这个目的地址就可以实现对IP的修改

  ;既然jmp中不包含转移的目的地址,那么CPU如何知道将IP改为多少呢？
  ;CPU在执行EB 03时候，根据指令码中的 03来转移
  ;EB 03并没有告诉CPU要转移的目的地址，告诉了CPU要转移的位移，即当前IP向后移动3个字节
  ;程序9.1和9.2中的jmp指令转移的位移相同，都是后3个字节,所以他们的机器码都是EB 03
  ;也就是，"jmp short 标号"指令所对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移
  ;具体的计算方法如图9.3所示
  ```
  - ![Minion](../pics/9.3.png)

- **“jmp short 标号” 的功能为: (IP) = (IP)+8位位移**
  - 8位位移 = 标号处的地址 - jmp指令后的第一个字节的地址
  - short 指明此处的位移为8 位位移
  - 8位位移的范围为-128~127，用补码表示
  - 8位位移由编译程序在编译时算出
- **还有一种和“jmp short 标号”功能相近的指令格式，jmp near ptr 标号，它实现的是段内近转移**
  - “jmp near ptr 标号” 的功能为: (IP) =（IP+16位位移)
  - 16位位移 = 标号处的地址 - jmp指令后的第一个字节的地址
  - near ptr指明此处的位移为16位位移，进行的是段内近转移
  - 16位位移的范围为 -32768～32767，用补码表示
  - 16位位移由编译程序在编译时算出
